<#.SYNOPSIS      WarmUP script for SharePoint 2010, 2013 & 2016.DESCRIPTION  	SPSWakeUp is a PowerShell script tool to warm up all site collection in your SharePoint environment.	It's compatible with all supported versions for SharePoint (2007, 2010 and 2013).	Use Internet Explorer to download JS, CSS and Pictures files, 	Log script results in rtf file, 	Email nofications, 	Configure automatically prerequisites for a best warm-up, 	Possibility to add or remove custom url.PARAMETER InputFile	Need parameter input file, example: 	PS D:\> E:\SCRIPT\SPSWakeUP.ps1 "E:\SCRIPT\SPSWakeUP.xml".EXAMPLE	SPSWakeUP.ps1 "E:\SCRIPT\SPSWakeUP.xml".NOTES  	FileName:	SPSWarmUP.ps1	Author:		Jean-Cyril DROUHIN	Date:		December 15, 2015	Version:	2.1.0	Licence:	MS-PL.LINK	https://spswakeup.codeplex.com/#>	param (    [Parameter(Mandatory=$false,Position=0)][string]$InputFile,    [Parameter(Mandatory=$false,Position=1)][switch]$Install)Clear-Host$Host.UI.RawUI.WindowTitle = " -- WarmUP script -- $env:COMPUTERNAME --"$spsWakeupVersion = "2.1.0"# Logging PowerShell script in rtf file $logfolder = Split-Path -parent $MyInvocation.MyCommand.Definition$logTime = Get-Date -Format yyyy-MM-dd_H-mm$logFile = $logfolder+"\WarmUP_script_$logTime.log"$currentuser = ([Security.Principal.WindowsIdentity]::GetCurrent()).Name#Get the content of the SPSWakeUP.xml fileif(!$InputFile){$InputFile = $logfolder+"\SPSWakeUP.xml"}if(Test-Path $InputFile){	[xml]$xmlinput = (Get-Content $InputFile -ReadCount 0)}#Define Global VariableNew-variable -Name logFileContent -scope "Global" -forceNew-variable -Name MailContent -scope "Global" -force$logFileContent =  New-Object System.Collections.Generic.List[string]# ====================================================================================# INTERNAL FUNCTIONS# ====================================================================================#region logging and trap exception# ===================================================================================# Func: Write-LogException# Desc: write Exception in powershell session and in error file# ===================================================================================Function Write-LogException{    Param([Parameter(Mandatory=$true,Position=0)]$ErrLog)	Add-LogContent "Yellow" "   * Exception Message: $($ErrLog.Exception.Message)"    $pathErrLog = Join-Path -Path $logfolder -ChildPath (((Get-Date).Ticks.ToString())+"_errlog.xml")    $ErrLog | Export-Clixml -Path $pathErrLog -Depth 3}# ===================================================================================# Func: Save-LogFile# Desc: Save logFile in current folder# ===================================================================================Function Save-LogFile{	Param 	(		[Parameter(Mandatory=$true,Position=0)][string]$Path	)	$pathLogFile = New-Object -TypeName System.IO.StreamWriter($Path)	ForEach($logFileC in $logFileContent)	{		$pathLogFile.WriteLine($logFileC)	}	$pathLogFile.Close()}# ===================================================================================# Func: Add-LogContent# Desc: Add Content in log file# ===================================================================================Function Add-LogContent{	Param	(		[Parameter(Mandatory=$true,Position=0)][string]$logColor,		[Parameter(Mandatory=$true,Position=1)][string]$logText,        [Parameter(Mandatory=$false,Position=2)][switch]$noNewLine	)	if($noNewLine)    {        Write-Host -ForegroundColor $logColor "$logText" -NoNewline    }    Else{Write-Host -ForegroundColor $logColor "$logText"}	$logFileContent.Add($logText)	$global:MailContent += $logText}# ===================================================================================# Func: Send-SPSLog# Desc: Send Email with log file in attachment# ===================================================================================Function Send-SPSLog{	Param 	(		[Parameter(Mandatory=$true,Position=0)][xml]$XmlFile,		[Parameter(Mandatory=$true,Position=1)]$MailAttachment,		[Parameter(Mandatory=$true,Position=2)]$MailBody	)		If($XmlFile.Configuration.EmailNotification.Enable -eq $true)	{		$MailAddress = $XmlFile.Configuration.EmailNotification.EmailAddress		$SMTPServer = $XmlFile.Configuration.EmailNotification.SMTPServer		$MailSubject = "Automated Script - WarmUp Urls - $env:COMPUTERNAME"		Add-LogContent "White" "--------------------------------------------------------------"		Add-LogContent "White" " - Sending Email with Log file to $MailAddress ..."		Try		{			Send-MailMessage -To $MailAddress -From $MailAddress -Subject $MailSubject -Body $MailBody -BodyAsHtml -SmtpServer $SMTPServer -Attachments $MailAttachment -ea stop			Add-LogContent "Green" " - Email sent successfully to $MailAddress"		}		Catch 		{			Write-LogException "$_"		}	}}# ===================================================================================# Func: Clear-SPSLog# Desc: Clean Log Files# ===================================================================================Function Clear-SPSLog{	Param 	(		[Parameter(Mandatory=$true,Position=0)][xml]$XmlFile,		[Parameter(Mandatory=$true,Position=1)][string]$path	)		If($XmlFile.Configuration.Settings.CleanLogs.Enable -eq $true)	{		If(Test-Path $path)		{			# Days of logs that will be remaining after log cleanup. 			$days = $XmlFile.Configuration.Settings.CleanLogs.Days						# Get the current date			$Now = Get-Date						# Definie the extension of log files			$Extension = "*.log"						# Define LastWriteTime parameter based on $days			$LastWrite = $Now.AddDays(-$days)						# Get files based on lastwrite filter and specified folder			$Files = Get-Childitem -Path "$path\*.*" -Include $Extension | Where {$_.LastWriteTime -le "$LastWrite"}						If($Files)			{				Add-LogContent "White" "--------------------------------------------------------------"				Add-LogContent "White" " - Cleaning log files in $path ..."				foreach ($File in $Files) 				{					If ($File -ne $NULL)					{						Add-LogContent "Yellow" " * Deleting File $File ..."						Remove-Item $File.FullName | out-null					}					Else					{						Add-LogContent "White" " - No more log files to delete "						Add-LogContent "White" "--------------------------------------------------------------"					}				}			}		}	}	Else	{		Add-LogContent "White" "--------------------------------------------------------------" 		Add-LogContent "Yellow" " Clean of logs is disabled in XML input file. "		Add-LogContent "White" "--------------------------------------------------------------"		}}#endregion#region Installation in Task Scheduler# ===================================================================================# Func: Get-SPSUserPassword# Desc: Get Password from Service Account# ===================================================================================Function Get-SPSUserPassword{	Param 	(		[Parameter(Mandatory=$true,Position=0)][string]$user	)    [System.Reflection.Assembly]::LoadWithPartialName('Microsoft.VisualBasic') | Out-Null    $password = [Microsoft.VisualBasic.Interaction]::InputBox("Enter the password of $user", "User Account Information", "")    Try    {        If (($password -ne "") -and ($user -ne ""))        {            $currentDomain = "LDAP://" + ([ADSI]"").distinguishedName            Add-LogContent "White" " - Account `"$user`" ..." -noNewLine            $dom = New-Object System.DirectoryServices.DirectoryEntry($currentDomain,$user,$password)            If ($dom.Path -eq $null)            {                Write-Host -BackgroundColor Red -ForegroundColor Black "Invalid!"            }            Else{Write-Host -ForegroundColor Black -BackgroundColor Green "Verified."}        }    }    Catch    {        Add-LogContent "Yellow" "An error occurred checking password for `"$user`""        Write-LogException "$_"	    }    $password}# ===================================================================================# Func: Add-SPSTask# Desc: Add SPSWakeUP Task in Task Scheduler# ===================================================================================Function Add-SPSTask{	Param 	(		[Parameter(Mandatory=$true,Position=0)][string]$Path,        [Parameter(Mandatory=$true,Position=1)][xml]$XmlFile	)    If(($XmlFile.Configuration.Install.Enable -eq "true") -OR ($Install))	{                $TrigSubscription =@"<QueryList><Query Id="0" Path="System"><Select Path="System">*[System[Provider[@Name='Microsoft-Windows-IIS-IISReset'] and EventID=3201]]</Select></Query></QueryList>"@        $TaskDate = Get-Date -Format yyyy-MM-dd        $TaskName = "SPSWakeUP"        $Hostname = $Env:computername        # Connect to the local TaskScheduler Service        $TaskSvc = New-Object -ComObject ("Schedule.service")        $TaskSvc.Connect($Hostname)        $TaskFolder = $TaskSvc.GetFolder("\")        $TaskSPSWKP = $TaskFolder.GetTasks(0) | Where {$_.Name -eq $TaskName}        $TaskCmd = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"        $inputFileFullPath = (Get-Item $InputFile).FullName;        $TaskCmdArg = @"-Command Start-Process "$PSHOME\powershell.exe" -Verb RunAs -ArgumentList "'-ExecutionPolicy Bypass ""$path\SPSWakeUP.ps1 -inputFile $inputFileFullPath""'""@        If ($TaskSPSWKP)        {            Add-LogContent "Yellow" "   * Shedule Task already exists - skipping."        }        Else        {			Add-LogContent "White" "--------------------------------------------------------------"			Add-LogContent "White" " - Adding SPSWakeUP script in Task Scheduler Service ..."			# Get Credentials for Task Schedule			$TaskAuthor = ([Security.Principal.WindowsIdentity]::GetCurrent()).Name			$TaskUser =  $XmlFile.Configuration.Install.ServiceAccount.UserName			#$TaskUserPwd = Get-SPSUserPassword $TaskUser			$TaskUserPwd = $XmlFile.Configuration.Install.ServiceAccount.Password            # Add a New Task Schedule            $TaskSchd = $TaskSvc.NewTask(0)            $TaskSchd.RegistrationInfo.Description = "SPSWakeUp Task - Start at 6:00 daily"            $TaskSchd.RegistrationInfo.Author = $TaskAuthor            $TaskSchd.Principal.RunLevel = 1            # Task Schedule - Modify Settings Section            $TaskSettings = $TaskSchd.Settings            $TaskSettings.AllowDemandStart = $true            $TaskSettings.Enabled = $true            $TaskSettings.Hidden = $false            $TaskSettings.StartWhenAvailable = $true            # Task Schedule - Trigger Section            $TaskTriggers = $TaskSchd.Triggers            # Add Trigger Type 2 OnSchedule Daily Start at 6:00 AM            $TaskTrigger1 = $TaskTriggers.Create(2)            $TaskTrigger1.StartBoundary = $TaskDate + "T06:00:00"            $TaskTrigger1.DaysInterval = 1            if($XmlFile.Configuration.Install.Repetition.Enable -eq $true)            {                $TaskTrigger1.Repetition.Duration = $XmlFile.Configuration.Install.Repetition.Duration                $TaskTrigger1.Repetition.Interval = $XmlFile.Configuration.Install.Repetition.Interval            }            $TaskTrigger1.Enabled = $true            # Add Trigger Type 8 At StartUp Delay 10M            $TaskTrigger2 = $TaskTriggers.Create(8)            $TaskTrigger2.Delay = "PT10M"            $TaskTrigger2.Enabled = $true            # Add Trigger Type 0 OnEvent IISReset            $TaskTrigger3 = $TaskTriggers.Create(0)            $TaskTrigger3.Delay = "PT20S"            $TaskTrigger3.Subscription = $TrigSubscription            $TaskTrigger3.Enabled = $true            $TaskAction = $TaskSchd.Actions.Create(0)            $TaskAction.Path = $TaskCmd            $TaskAction.Arguments = $TaskCmdArg            Try            {                $TaskFolder.RegisterTaskDefinition( $TaskName, $TaskSchd, 6, $TaskUser , $TaskUserPwd , 1)                Add-LogContent "Green" "   * Successfully added SPSWakeUP script in Task Scheduler Service"            }            Catch		    {                Add-LogContent "Yellow" "An error occurred adding Scheduled Task for `"$TaskUser`""				Write-LogException "$_"			    		    }        }    }}#endregion# Region Load SharePoint Powershell Snapin for SharePoint 2010, 2013 & 2016# ===================================================================================# Name: 		Add-PSSharePoint# Description:	Load SharePoint Powershell Snapin# ===================================================================================Function Add-PSSharePoint{    If ((Get-PsSnapin | Where {$_.Name -eq "Microsoft.SharePoint.PowerShell"})-eq $null)    {        Add-LogContent "White" "--------------------------------------------------------------"        Add-LogContent "Cyan" " - Loading SharePoint Powershell Snapin..."        Add-PsSnapin Microsoft.SharePoint.PowerShell -ErrorAction Stop | Out-Null        Add-LogContent "White" "--------------------------------------------------------------"    }}# ===================================================================================# Name: 		Add-RASharePoint# Description:	Load SharePoint Assembly for SharePoint 2007, 2010, 2013 & 2016# ===================================================================================Function Add-RASharePoint{	Add-LogContent "White" "--------------------------------------------------------------"	Add-LogContent "Cyan" " - Loading Microsoft.SharePoint Assembly..."	[System.Reflection.Assembly]::LoadWithPartialName("Microsoft.SharePoint") | Out-Null	Add-LogContent "White" "--------------------------------------------------------------"}# ===================================================================================# Name: 		Add-SystemWeb# Description:	Load System.Web with Reflection Assembly# ===================================================================================Function Add-SystemWeb{	If($xmlinput.Configuration.Settings.UseIEforWarmUp -eq $false)	{		Add-LogContent "White" "--------------------------------------------------------------"		Add-LogContent "Cyan" " - Loading System.Web ..."		[System.Reflection.Assembly]::LoadWithPartialName("system.web") | Out-Null		Add-LogContent "White" "--------------------------------------------------------------"	}}# ===================================================================================# Name: 		Get-SPSThrottleLimit# Description:	Get Number Of Throttle Limit# ===================================================================================Function Get-SPSThrottleLimit{	Begin	{		Add-LogContent "White" "--------------------------------------------------------------"		Add-LogContent "White" " - Get Number Of Throttle Limit (from NumberOfLogicalProcessors)"		[int]$NumThrottle = 8 	}		Process	{		# Get Number Of Throttle Limit 		$NCpu = (Get-WmiObject Win32_Processor | measure -Property NumberOfLogicalProcessors -Sum).Sum		If ($NCpu -le 2)		{			$NumThrottle = 2*$NCpu		}		ElseIf ($NCpu -ge 8)		{			$NumThrottle = 10		}		Else {$NumThrottle = 2*$NCpu}		Add-LogContent "White" " * Number Of Throttle Limit will be $NumThrottle"	}	End	{			return $NumThrottle		Add-LogContent "White" " "	}}#endregion#region get all site collections and all web applications# ===================================================================================# Name: 		Add-SPSSitesUrl# Description:	Add Site Collection Url and FBA settings in PSObject# ===================================================================================Function Add-SPSSitesUrl{	Param 	(		[Parameter(Mandatory=$true,Position=0)][string]$Url,        [Parameter(Mandatory=$true,Position=1)][bool]$Fba = $false,        [Parameter(Mandatory=$true,Position=2)][bool]$Win = $true	)	$pso = New-Object PSObject	$pso | Add-Member -Name Url -MemberType NoteProperty -Value $Url	$pso | Add-Member -Name FBA -MemberType NoteProperty -Value $Fba    $pso | Add-Member -Name Win -MemberType NoteProperty -Value $Win	$pso}# ===================================================================================# Name: 		Get-SPSSitesUrl# Description:	Get All Site Collections Url# ===================================================================================Function Get-SPSSitesUrl{	Param ([Parameter(Mandatory=$true,Position=0)][xml]$xmlinput)		Begin	{		Add-LogContent "White" "--------------------------------------------------------------"		Add-LogContent "White" " - Get URLs of All Site Collection ... Please waiting"		# Variable Declaration		$tbSitesURL = New-Object System.Collections.ArrayList		$ExcludeUrls = $xmlinput.Configuration.ExcludeUrls.ExcludeUrl		$CustomUrls = $xmlinput.Configuration.CustomUrls.CustomUrl		$defaultUrlZone = [Microsoft.SharePoint.Administration.SPUrlZone]::Default		[bool]$fbaSParameter = $false        [bool]$winParameter = $true		$NumSites = 0	}		Process	{        try        {        	If ($xmlinput.Configuration.Settings.WarmupWebSvc -eq $true)			{				# Import module WebAdministration				Import-Module WebAdministration								# Add SharePoint Web Services (.svc) in warmup							$iisSPWebServices = Get-ChildItem 'IIS:\Sites\SharePoint Web Services' -recurse | where {$_.Name -like "*svc"}				if($iisSPWebServices)				{					foreach($iisSPWebService in $iisSPWebServices)					{						$iisSPWebServiceUrl = Get-WebURL $iisSPWebService.PSPath												[void]$tbSitesURL.Add((Add-SPSSitesUrl -Url $iisSPWebServiceUrl.ResponseUri.AbsoluteUri.ToString() -FBA $false -Win $true))					}				}				Add-LogContent "White" "   * SharePoint Web services included in WarmUp Urls"			}                        # Get url of CentralAdmin if include in input xml file		    If ($xmlinput.Configuration.Settings.IncludeCentralAdmin -eq $true)		    {			    $WebAppADM = [microsoft.sharepoint.administration.SPAdministrationWebApplication]::Local			    $SitesADM = $WebAppADM.sites			    foreach ($site in $SitesADM)			    { 				    #[void]$SitesURL.Add($sites.Url)				    [void]$tbSitesURL.Add((Add-SPSSitesUrl -Url $site.Url -FBA $false -Win $true))				    $site.Dispose() 			    }			    Add-LogContent "White" "   * Central Administration included in WarmUp Urls"		    }		    Else		    {			    Add-LogContent "White" "   * Central Administration excluded from WarmUp Urls"		    }				    # Get Url of all site collection		    $WebSrv = [microsoft.sharepoint.administration.spwebservice]::ContentService		    $webApps = $WebSrv.WebApplications				    ForEach($webApp in $webApps)		    {			    $iisSettings = $webApp.GetIisSettingsWithFallback($defaultUrlZone)			    $getClaimProviderForms = $iisSettings.ClaimsAuthenticationProviders | Where {$_.ClaimProviderName -eq "Forms"}                $getClaimProviderWindows = $iisSettings.ClaimsAuthenticationProviders | Where {$_.ClaimProviderName -eq "AD"}			                if($getClaimProviderForms){$fbaSParameter = $true}else{$fbaSParameter=$false}                if($getClaimProviderWindows){$winParameter = $true}else{$winParameter=$false}			    $sites = $webApp.sites			    ForEach($site in $sites)			    {                    if(($fbaSParameter -eq $true) -and ($winParameter -eq $true)){$siteUrl = $site.Url + "/_windows/default.aspx?ReturnUrl=/_layouts/15/Authenticate.aspx?Source=%2f" }else{$siteUrl = $site.Url}				    [void]$tbSitesURL.Add((Add-SPSSitesUrl -Url $siteUrl -FBA $fbaSParameter -Win $winParameter))				    $site.Dispose()				    $NumSites++			    }		    }		    Add-LogContent "White" "   * $NumSites site collection will be waking up ..."				    # Remove Site Collection Urls from WarmUp		    If ($ExcludeUrls.Length -ne 0)		    {			    Add-LogContent "White" " - Site Collection Urls Excluded from WarmUp :"			    $global:MailContent += "<br>Site Collection Urls Excluded from WarmUp :<br>"			    ForEach($ExcludeUrl in $ExcludeUrls)			    {				    Add-LogContent "White" "   * $ExcludeUrl"				    $global:MailContent += "$ExcludeUrl<br>"				    [void]$tbSitesURL.Remove($ExcludeUrl)			    }		    }				    # Add Custom Urls in WarmUp		    If ($CustomUrls.Length -ne 0)		    {			    Add-LogContent "White" " - Custom Urls added in WarmUp :"			    $global:MailContent += "<br>Custom Urls added in WarmUp :<br>"			    ForEach($CustomUrl in $CustomUrls)			    {				    $stCustomUrl = $CustomUrl.url                    Add-LogContent "White" "   * $stCustomUrl"				    $global:MailContent += "$stCustomUrl<br>"                    if(($CustomUrl.fba).ToLower() -eq "true"){$fbaSParameter=$true}Else{$fbaSParameter=$false}                    if(($CustomUrl.windows).ToLower() -eq "true"){$winParameter=$true}Else{$winParameter=$false}				    [void]$tbSitesURL.Add((Add-SPSSitesUrl -Url $stCustomUrl -FBA $fbaSParameter -Win $winParameter))			    }		    }        }        Catch        {            Add-LogContent "Yellow" "An error occurred getting all site collections"			Write-LogException "$_"		        }	}		End	{		$tbSitesURL		Add-LogContent "White" " "	}}# ===================================================================================# Name: 		Get-SPSHSNCUrl# Description:	Get All Host Named Site Collection Url# ===================================================================================Function Get-SPSHSNCUrl{	Begin	{		Add-LogContent "White" "--------------------------------------------------------------"		Add-LogContent "White" " - Get URLs of All Host Named Site Collection ..."		# Variable Declaration		$hsncURL = New-Object System.Collections.ArrayList		$WebSrv = [microsoft.sharepoint.administration.spwebservice]::ContentService	}	Process	{		$webApps = $WebSrv.WebApplications		$sites = $webApps | ForEach-Object {$_.sites}		$HSNCs = $sites | Where-Object {$_.HostHeaderIsSiteName -eq $true}		ForEach($HSNC in $HSNCs)		{			[void]$hsncURL.Add($HSNC.Url)			$HSNC.Dispose()		}	}		End	{		$hsncURL		Add-LogContent "White" " "	}}# ===================================================================================# Name: 		Get-SPSWebAppUrl# Description:	Get All Web Applications Url# ===================================================================================Function Get-SPSWebAppUrl{	Begin	{		Add-LogContent "White" "--------------------------------------------------------------"		Add-LogContent "White" " - Get URLs of All Web Applications ..."		$WebAppURL = New-Object System.Collections.ArrayList		$WebSrv = [microsoft.sharepoint.administration.spwebservice]::ContentService	}		Process	{		$webApps = $WebSrv.WebApplications		foreach ($webapp in $webApps)		{			[void]$WebAppURL.Add($webapp.GetResponseUri("Default").AbsoluteUri)		}	}	End	{			$WebAppURL		Add-LogContent "White" " "	}}#endregion#region Invoke webRequest and IEwebRequest# ===================================================================================# Name: 		Get-SPSWebRequest# Description:	Request Url with System.Net.WebClient Object# ===================================================================================Function Get-SPSWebRequest{	Param([Parameter(Mandatory=$true,Position=0)]$Urls)		ForEach ($Url in $Urls)	{		$TimeStart = Get-Date		$WebRequestObject = [System.Net.HttpWebRequest] [System.Net.WebRequest]::Create($Url)		$WebRequestObject.UseDefaultCredentials = $true		$WebRequestObject.Method = "GET"		$WebRequestObject.Accept = "text/html"		$WebRequestObject.Timeout = 80000		Add-LogContent "White" " - Web Request for url: $url"		$global:MailContent += " - Web Request for url: $url"		try		{			# Get the response of $WebRequestObject			$ResponseObject = [System.Net.HttpWebResponse] $WebRequestObject.GetResponse()			$TimeStop = Get-Date			$TimeExec = ($TimeStop - $TimeStart).TotalSeconds			'{0,-30} : {1,10:#,##0.00} s' -f '   WebSite successfully loaded in', $TimeExec			#Add-LogContent "Green" "   * WebSite successfully loaded in $TimeExec s"			$global:MailContent += "<br><font color=green>WebSite successfully loaded in $TimeExec s</font><br>"		}		catch [Net.WebException]		{			Write-LogException "$_"		}		finally 		{			# Issue 1451 - https://spswakeup.codeplex.com/workitem/1451			# Thanks to Pupasini - Closing the HttpWebResponse object					if ($ResponseObject) 			{				$ResponseObject.Close()				Remove-Variable ResponseObject			}		}	}}# ===================================================================================# Name: 		Invoke-SPSWebRequest# Description:	Multi-Threading Request Url with System.Net.WebClient Object# ===================================================================================Function Invoke-SPSWebRequest{	Param	(		[Parameter(Mandatory=$true,Position=0)]$Urls,		[Parameter(Mandatory=$true,Position=1)]$throttleLimit,        [Parameter(Mandatory=$true,Position=2)][xml]$xmlinput	)        # Get UserAgent from XML input file if no exist get UserAgent from current OS	$userAgent = $xmlinput.Configuration.Settings.UserAgent    if([string]::IsNullOrEmpty($userAgent))    {        $userAgent = [Microsoft.PowerShell.Commands.PSUserAgent]::InternetExplorer    }    $iss = [system.management.automation.runspaces.initialsessionstate]::CreateDefault()	$Pool = [runspacefactory]::CreateRunspacePool(1, $throttleLimit, $iss, $Host)	$Pool.Open()	$ScriptBlock = 	{		Param        (            [Parameter(Mandatory=$true,Position=0)]$url,            [Parameter(Mandatory=$false,Position=1)]$useragent        )        Process         {                    Function Get-GenericWebRequest()            {                Param	            (		            [Parameter(Mandatory=$true,Position=0)]$URL,                    [Parameter(Mandatory=$false,Position=0)]$AllowAutoRedirect = $true	            )                Process                 {                    $GenericWebRequest = [System.Net.HttpWebRequest][System.Net.WebRequest]::Create($URL)                    $GenericWebRequest.UseDefaultCredentials = $true                    $GenericWebRequest.Method = "GET"                    $GenericWebRequest.UserAgent = $useragent                    $GenericWebRequest.Accept = "text/html"                    $GenericWebRequest.Timeout = 80000                    $GenericWebRequest.AllowAutoRedirect = $AllowAutoRedirect
                    if(((Get-Host).Version.Major) -gt 2){$GenericWebRequest.ServerCertificateValidationCallback = { $true }}                    $GenericWebRequest                }            }        		    $TimeStart = Get-Date;            $fedAuthwebrequest = Get-GenericWebRequest -URL $url -AllowAutoRedirect $false;		    try		    {			    # Get the response of $WebRequestObject                $fedAuthwebresponse = [System.Net.HttpWebResponse] $fedAuthwebrequest.GetResponse()                $fedAuthCookie = $fedAuthwebresponse.Headers["Set-Cookie"];                $httpwebrequest = Get-GenericWebRequest -URL $Url -AllowAutoRedirect $true;                $httpwebrequest.Headers.Add("Cookie", "$fedAuthCookie");            			    $ResponseObject = [System.Net.HttpWebResponse] $httpwebrequest.GetResponse()			    $TimeStop = Get-Date			    $TimeExec = ($TimeStop - $TimeStart).TotalSeconds			    $TimeExec = "{0:N2}" -f $TimeExec			    $Response = "$([System.int32]$ResponseObject.StatusCode) - $($ResponseObject.StatusCode)"		    }		    catch [Net.WebException]		    {			    $Response = $_.Exception.Message		    }		    finally 		    {			    if ($ResponseObject) 			    {				    $ResponseObject.Close()				    Remove-Variable ResponseObject			    }		    }		    $RunResult = New-Object PSObject		    $RunResult | Add-Member -MemberType NoteProperty -Name Url -Value $url		    $RunResult | Add-Member -MemberType NoteProperty -Name 'Time(s)' -Value $TimeExec		    $RunResult | Add-Member -MemberType NoteProperty -Name Status -Value $Response		    $RunResult        }	}				    
    Try
    {
    	   $Jobs = @()
       ForEach ($Url in $Urls)
       {
            $Job = [powershell]::Create().AddScript($ScriptBlock).AddParameter("URL",$Url.Url).AddParameter("UserAgent",$userAgent)            $Job.RunspacePool = $Pool
    	    $Jobs += New-Object PSObject -Property @{    		    Url = $Url.Url    		    Pipe = $Job    		    Result = $Job.BeginInvoke()
            }
       }    	Write-Host " - Please Wait.." -NoNewline    	While ($Jobs.Result.IsCompleted -contains $false)    	{    	   Write-Host "." -NoNewline    	   Start-Sleep -S 1    	}     	$Results = @()    	ForEach ($Job in $Jobs)    	{       		$Results += $Job.Pipe.EndInvoke($Job.Result)    	}    	
    }
    Catch
    {
        Add-LogContent "Yellow" "An error occurred invoking multi-threading function"        Write-LogException "$_"
    }
        Finally
    {
        $Pool.Dispose()
    }    $Results}# ===================================================================================# Name: 		Get-IEWebRequest# Description:	Open Url in Internet Explorer Window# ===================================================================================Function Get-IEWebRequest($urls){	# Run Internet Explorer	$global:ie = New-Object -com "InternetExplorer.Application"	$global:ie.Navigate("about:blank")	$global:ie.visible = $true	$global:ieproc = (Get-Process -Name iexplore)| Where-Object {$_.MainWindowHandle -eq $global:ie.HWND}		ForEach ($url in $urls)	{		Add-LogContent "White" " - Internet Explorer - Browsing $url"		$global:MailContent += "- Browsing $url"		$TimeOut = 90		$Wait = 0		try		{			$global:ie.Navigate($url)			While ($ie.busy -like "True" -Or $Wait -gt $TimeOut)			{				Start-Sleep -s 1				$Wait++			}			Add-LogContent "Green" "   * WebSite successfully loaded in $Wait s"			$global:MailContent += "<br><font color=green>WebSite successfully loaded in $Wait s</font><br>"		}		catch		{			$pid = $global:ieproc.id			Add-LogContent "Red" "  IE not responding.  Closing process ID $pid"			$global:ie.Quit()			$global:ieproc | Stop-Process -Force			$global:ie = New-Object -com "InternetExplorer.Application"			$global:ie.Navigate("about:blank")			$global:ie.visible = $true			$global:ieproc = (Get-Process -Name iexplore)| Where-Object {$_.MainWindowHandle -eq $global:ie.HWND}		}	}	# Quit Internet Explorer	if ($global:ie)	{		Add-LogContent "White" "--------------------------------------------------------------"		Add-LogContent "White" " - Closing Internet Explorer ..."		$global:ie.Quit()	}}# ===================================================================================# Name: 		Invoke-IEWebRequest# Description:	Multi-Threading Request Url in Internet Explorer Window# ===================================================================================Function Invoke-IEWebRequest{	Param	(		[Parameter(Mandatory=$true,Position=0)]$Urls,		[Parameter(Mandatory=$true,Position=1)]$throttleLimit	)		$iss = [system.management.automation.runspaces.initialsessionstate]::CreateDefault()	$Pool = [runspacefactory]::CreateRunspacePool(1, $throttleLimit, $iss, $Host)	$Pool.Open()			$ScriptBlock = 	{		$RunResult	}	$Jobs = @()	$Urls | Where {                $url = $_.Url        		# Run Internet Explorer		$ie = New-Object -com "InternetExplorer.Application"		$ie.Navigate("about:blank")		$ie.visible = $true		$ieproc = (Get-Process -Name iexplore)| Where {$_.MainWindowHandle -eq $ie.HWND}				$TimeOut = 90		$Wait = 0		try		{			$ie.Navigate($url)			While ($ie.busy -like "True" -Or $Wait -gt $TimeOut)			{				Start-Sleep -s 1				$Wait++			}			$Response = "OK"		}		catch		{			$pid = $ieproc.id			$Response = "IE not responding.  Closing process ID $pid"			$ie.Quit()			$ieproc | Stop-Process -Force			$ie = New-Object -com "InternetExplorer.Application"			$ie.Navigate("about:blank")			$ie.visible = $true			$ieproc = (Get-Process -Name iexplore)| where {$_.MainWindowHandle -eq $ie.HWND}		}		finally		{			$ie.Quit()			#$ieproc | Stop-Process -Force 		}		$RunResult = New-Object PSObject		$RunResult | Add-Member -MemberType NoteProperty -Name Url -Value $url		$RunResult | Add-Member -MemberType NoteProperty -Name 'Time(s)' -Value $Wait		$RunResult | Add-Member -MemberType NoteProperty -Name Status -Value $Response	}	Write-Host " - Please Wait.." -NoNewline	While ($Jobs.Result.IsCompleted -contains $false)	{	   Write-Host "." -NoNewline	   Start-Sleep -s 1	} 	$Results = @()	ForEach ($Job in $Jobs)	{   		$Results += $Job.Pipe.EndInvoke($Job.Result)	} 	$Pool.Dispose()	$Results}#endregion#region Configuration and permission# ===================================================================================# Func: Disable-LoopbackCheck# Desc: Disable Loopback Check# ===================================================================================Function Disable-LoopbackCheck{	Param	(		[Parameter(Mandatory=$true,Position=0)][xml]$XmlFile,		[Parameter(Mandatory=$true,Position=1)]$urls	)    	# Disable the Loopback Check on stand alone demo servers.    # This setting usually kicks out a 401 error when you try to navigate to sites that resolve to a loopback address e.g.  127.0.0.1    If ($XmlFile.Configuration.Settings.DisableLoopbackCheck -eq "true")    {        		$lsaPath = "HKLM:\System\CurrentControlSet\Control\Lsa"        $lsaPathValue = Get-ItemProperty -path $lsaPath        If (-not ($lsaPathValue.DisableLoopbackCheck -eq "1"))        {			Add-LogContent "White" " - Disabling Loopback Check..."            New-ItemProperty HKLM:\System\CurrentControlSet\Control\Lsa -Name "DisableLoopbackCheck" -value "1" -PropertyType dword -Force | Out-Null        }		Else		{			Add-LogContent "White" " - Loopback Check already Disabled - skipping."		}    }	ElseIf($XmlFile.Configuration.Settings.DisableLoopbackCheck -eq "secure")	{		$lsaPath = "HKLM:\System\CurrentControlSet\Control\Lsa"		$paramPath = "HKLM:System\CurrentControlSet\Services\LanmanServer\Parameters"		$mvaPath = "HKLM:\System\CurrentControlSet\Control\Lsa\MSV1_0"        $lsaPathValue = Get-ItemProperty -path $lsaPath		$paramPathValue = Get-ItemProperty -path $paramPath        If ($lsaPathValue.DisableLoopbackCheck -eq "1")        {			Add-LogContent "White" " - Disabling Loopback Check - Back to default value ..."            New-ItemProperty $lsaPath -Name "DisableLoopbackCheck" -value "0" -PropertyType dword -Force | Out-Null        }        If (-not($paramPathValue.DisableStrictNameChecking -eq "1"))        {			Add-LogContent "White" " - Disabling Strict Name Checking ..."            New-ItemProperty $paramPath -Name "DisableStrictNameChecking" -value "1" -PropertyType dword -Force | Out-Null        }		$BackCoName = Get-ItemProperty -Path $mvaPath -Name BackConnectionHostNames -ea SilentlyContinue		If (!($BackCoName))		{			New-ItemProperty $mvaPath -Name "BackConnectionHostNames" -PropertyType multistring -Force | Out-Null		}		ForEach ($url in $urls)		{			$url = $url -replace "https://",""			$url = $url -replace "http://",""			$hostname = $url -replace "/",""						If (!($BackCoName.BackConnectionHostNames -like "*$hostname*"))			{				Add-LogContent "White" " - Add $hostname in BackConnectionHostNames regedit key ..."                $BackCoNameNew = $BackCoName.BackConnectionHostNames + "$hostname"				New-ItemProperty $mvaPath -Name "BackConnectionHostNames" -Value $BackCoNameNew -PropertyType multistring -Force | Out-Null			}		}	}}# ====================================================================================# Func: Add-HostsEntry# Desc: This writes URLs to the server's local hosts file and points them to the server itself# From: Check http://toddklindt.com/loopback for more information# Copyright Todd Klindt 2011# Originally published to http://www.toddklindt.com/blog# ====================================================================================Function Add-HostsEntry{	Param	(		[Parameter(Mandatory=$true,Position=0)]$urls,		[Parameter(Mandatory=$true,Position=1)][xml]$XmlFile	)	If ($XmlFile.Configuration.Settings.AddURLsToHOSTS -eq "true")    {		Add-LogContent "White" "--------------------------------------------------------------"		Add-LogContent "White" " - Add Urls of All Web Applications or HSNC in HOSTS File ..."		ForEach ($url in $urls)		{			# Remove http or https information to keep only HostName or FQDN			$url = $url -replace "https://",""			$url = $url -replace "http://",""			$hostname = $url -replace "/",""					If ($hostname.Contains(":"))			{				Add-LogContent "White" " * $hostname cannot be added in HOSTS File, only web applications with 80 or 443 port are added ."			}			Else			{					# Make backup copy of the Hosts file with today's date				$hostsfile = "$env:windir\System32\drivers\etc\HOSTS"				$date = Get-Date -UFormat "%y%m%d%H%M%S"				$filecopy = $hostsfile + '.' + $date + '.copy'				# Get the contents of the Hosts file				$file = Get-Content $hostsfile -ReadCount 0				$file = $file | Out-String				# Write the AAMs to the hosts file, unless they already exist.				If ($file.Contains($hostname))				{Add-LogContent "White" " * HOSTS file entry for `"$hostname`" already exists - skipping."}				Else				{					Add-LogContent "White" " * Backing up HOSTS file to:"					Add-LogContent "White" " * $filecopy"					Copy-Item $hostsfile -Destination $filecopy								Add-LogContent "White" " * Adding HOSTS file entry for `"$hostname`"..."					Add-Content -Path $hostsfile -Value "`r"					Add-Content -Path $hostsfile -value "127.0.0.1 `t $hostname"				}			}		}	}}# ===================================================================================# Func: Add-SPSUserPolicy# Desc: Applies Read Access to the specified accounts for a web application# ===================================================================================Function Add-SPSUserPolicy{    Param	(		[Parameter(Mandatory=$true,Position=0)]$urls,		[Parameter(Mandatory=$true,Position=1)][xml]$XmlFile	)    $userName = $XmlFile.Configuration.Install.ServiceAccount.Username    Add-LogContent "White" "--------------------------------------------------------------"	Add-LogContent "White" " - Add Read Access to $user for All Web Applications ..."	ForEach ($url in $urls)	{		Try		{			$webapp = [Microsoft.SharePoint.Administration.SPWebApplication]::Lookup("$url")			#$user = ([Security.Principal.WindowsIdentity]::GetCurrent()).Name            			$displayName = "WarmUp Account"						# If the web app is not Central Administration 			If ($webapp.IsAdministrationWebApplication -eq $false)			{				# If the web app is using Claims auth, change the user accounts to the proper syntax				If ($webapp.UseClaimsAuthentication -eq $true)				{					#$user = 'i:0#.w|'+$userName					$user = (New-SPClaimsPrincipal -identity $userName -identitytype 1).ToEncodedString()  				}                Else{$user = $userName}				Add-LogContent "White" " - Applying Read access for $user account to $url..."				[Microsoft.SharePoint.Administration.SPPolicyCollection]$policies = $webapp.Policies				$PolicyExist = $policies | where {$_.Displayname -eq "WarmUp Account"}								If ($PolicyExist)				{					Add-LogContent "Yellow" "   * Read access for WarmUp Account already exists - skipping."				}				Else				{					[Microsoft.SharePoint.Administration.SPPolicy]$policy = $policies.Add($user, $displayName)                    $policyRole = $webApp.PolicyRoles.GetSpecialRole([Microsoft.SharePoint.Administration.SPPolicyRoleType]::FullRead)					If ($policyRole -ne $null)					{						$policy.PolicyRoleBindings.Add($policyRole)					}					$webapp.Update()					Add-LogContent "White" "   * Done Applying Read access for `"$user`" account to `"$url`""				}			}		}		Catch		{            Add-LogContent "Yellow" "An error occurred applying Read access for `"$user`" account to `"$url`""            Write-LogException "$_"		}	}}#endregion#region Internet Explorer Configuration# ===================================================================================# Name: 		Add-IETrustedSite# Description:	Add Url in Security Option - Intranet Zone# ===================================================================================Function Add-IETrustedSite{    Param	(		[Parameter(Mandatory=$true,Position=0)]$urls    )	Add-LogContent "White" "--------------------------------------------------------------"	Add-LogContent "White" " - Add URLs of All Web Applications in Internet Settings/Security ..."	ForEach ($url in $urls)	{		# Remove http or https information to keep only HostName or FQDN		$url = $url -replace "https://",""		$url = $url -replace "http://",""		$urlDomain = $url -replace "/",""		if (-not (Test-Path -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap\Domains\$urlDomain"))		{			Add-LogContent "White" " - Adding *.$urlDomain to local Intranet security zone..."			New-Item -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap\Domains" -Name $urlDomain -ItemType Leaf -Force | Out-Null			New-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap\Domains\$urlDomain" -Name '*' -value "1" -PropertyType dword -Force | Out-Null		}		Else		{			Add-LogContent "White" " - $urlDomain already added to local Intranet security zone - skipping."		}		if (-not (Test-Path -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap\EscDomains\$urlDomain"))		{			Add-LogContent "White" " - Adding *.$urlDomain to local Intranet security zone (IE ESC) ..."			New-Item -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap\EscDomains" -Name $urlDomain -ItemType Leaf -Force | Out-Null			New-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap\EscDomains\$urlDomain" -Name '*' -value "1" -PropertyType dword -Force | Out-Null		}		Else		{			Add-LogContent "White" " - $urlDomain already added to local Intranet security zone (IE ESC) - skipping."		}	}}# ===================================================================================# Name: 		Clear-IECache# Description:	Clear Internet Explorer's cache# ===================================================================================Function Clear-IECache {	$RunDll32 = "$env:windir\System32\rundll32.exe"	If (Test-Path -Path $RunDll32)	{		try		{			Add-LogContent "White" " - Cleaning Cache IE with runDll32.exe ..."			Start-Process -FilePath $RunDll32 -ArgumentList "InetCpl.cpl,ClearMyTracksByProcess 8" -NoNewWindow -Wait -ErrorAction Stop		}		Catch		{			Write-Warning "An error occurred attempting to clear internet explorer temporary files."		}	}	Else	{		Add-LogContent "White" " - Clear Cache IE - The rundll32 is not present in $env:windir\System32 folder"	}}# ===================================================================================# Name: 		Disable-IEESC# Description:	Disable Internet Explorer Enhanced Security Configuration for administrators# ===================================================================================Function Disable-IEESC{	Param ([Parameter(Mandatory=$true,Position=0)][xml]$XmlFile)	If($XmlFile.Configuration.Settings.DisableIEESC -eq $true)	{		Add-LogContent "White" "--------------------------------------------------------------"		Try		{						$AdminKey = "HKLM:\SOFTWARE\Microsoft\Active Setup\Installed Components\{A509B1A7-37EF-4b3f-8CFC-4F3A74704073}"			$AdminKeyValue = Get-ItemProperty -Path $AdminKey			If (-not ($AdminKeyValue.IsInstalled -eq "0"))			{				Add-LogContent "White" " - Disabling Internet Explorer Enhanced Security Configuration ..."				Set-ItemProperty -Path $AdminKey -Name "IsInstalled" -Value 0			}			Else			{				Add-LogContent "White" " - Internet Explorer ESC already Disabled - skipping."			}		}		Catch 		{			Add-LogContent "Yellow" "Failed to Disable Internet Explorer Enhanced Security Configuration"		}	}}# ===================================================================================# Func: Disable-IEFirstRun# Desc: Disable First Run for Internet Explorer# ===================================================================================Function Disable-IEFirstRun{    Add-LogContent "White" "--------------------------------------------------------------"	$lsaPath = "HKCU:\Software\Microsoft\Internet Explorer\Main"    $lsaPathValue = Get-ItemProperty -path $lsaPath    If (-not ($lsaPathValue.DisableFirstRunCustomize -eq "1"))    {		Add-LogContent "White" " - Disabling Internet Explorer First Run ..."        New-ItemProperty "HKCU:\Software\Microsoft\Internet Explorer\Main" -Name "DisableFirstRunCustomize" -value "1" -PropertyType dword -Force | Out-Null    }	Else	{		Add-LogContent "White" " - Internet Explorer First Run already Disabled - skipping."	}}#endregion#region Main# ===================================================================================## WarmUp Script - MAIN Region## ===================================================================================$DateStarted = Get-dateAdd-LogContent "Green" "-------------------------------------"Add-LogContent "Green" "| Automated Script - SPSWakeUp v$spsWakeupVersion |"Add-LogContent "Green" "| Started on : $DateStarted by $currentuser|"Add-LogContent "Green" "-------------------------------------"$global:MailContent = "Automated Script - WarmUp Urls - Started on: $DateStarted <br>"$global:MailContent += "SharePoint Server : $env:COMPUTERNAME<br>"# Check Permission LevelIf (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")){	Write-Warning "You do not have Administrator rights to run this script!`nPlease re-run this script as an Administrator!"	Break} else {	# Add SPSWakeup script in a new scheduled Task	Add-SPSTask -Path $logfolder -XmlFile $xmlinput	# Load SharePoint Powershell Snapin, Assembly and System.Web	Add-RASharePoint	Add-PSSharePoint	Add-SystemWeb	# Get Number Of Throttle Limit 	[int]$NumThrottle = Get-SPSThrottleLimit	# Get All Web Applications Urls and Host Named Site Collection	$getSPWebApps = Get-SPSWebAppUrl	$getSPSiteColN = Get-SPSHSNCUrl	# Disable LoopBack Check	Add-LogContent "White" "--------------------------------------------------------------"    Add-LogContent "White" " - Add Urls of All Web Applications or HSNC in BackConnectionHostNames regedit key ..."	Disable-LoopbackCheck $xmlinput $getSPWebApps	Disable-LoopbackCheck $xmlinput $getSPSiteColN	# Add Web Application and Host Named Site Collection Urls in HOSTS system File	Add-HostsEntry $getSPWebApps $xmlinput	Add-HostsEntry $getSPSiteColN $xmlinput		# Add read access for Warmup User account in User Policies settings	Add-SPSUserPolicy $getSPWebApps $xmlinput		# Get All Site Collections Urls	$getSPSites = Get-SPSSitesUrl $xmlinput	If($xmlinput.Configuration.Settings.UseIEforWarmUp -eq $true)	{		# Disable Internet Explorer Enhanced Security Configuration and First Run		Disable-IEESC $xmlinput		Disable-IEFirstRun				# Add Web Application Url in Intranet Security Options for Internet Explorer		Add-IETrustedSite $getSPWebApps        Add-IETrustedSite $getSPSiteColN		# Remove Internet Explorer Temporary Files with RunDll32.exe		Clear-IECache				# Request Url with Internet Explorer for All Site Collections Urls		Add-LogContent "White" "--------------------------------------------------------------"        Add-LogContent "White" " - Opening All sites Urls with Internet Explorer ..."		$global:MailContent += "<br>Opening All sites Urls with Internet Explorer ... <br>"		#Get-IEWebRequest $getSPSites		$InvokeResults = Invoke-IEWebRequest $getSPSites $NumThrottle	}	Else	{		# Request Url with System.Net.WebClient Object for All Site Collections Urls		Add-LogContent "White" "--------------------------------------------------------------"		Add-LogContent "Yellow" " - UseIEforWarmUp is set to False - Opening All sites Urls with Web Request ..."		$global:MailContent += "<br>Opening All sites Urls with Web Request Object, see log files for more details<br>"		#Get-SPSWebRequest $getSPSites		$InvokeResults = Invoke-SPSWebRequest $getSPSites $NumThrottle $xmlinput	}	# Show the results    ForEach ($InvokeResult in $InvokeResults)    {        $resultUrl = $InvokeResult.Url        $resultTime = $InvokeResult.'Time(s)'        $resultStatus = $InvokeResult.Status        Add-LogContent "White" " -----------------------------------"        Add-LogContent "White" " . Url    : $resultUrl"        Add-LogContent "White" " . Time   : $resultTime seconds"        Add-LogContent "White" " . Status : $resultStatus"    }	# Clean the folder of log files 	Clear-SPSLog -XmlFile $xmlinput -path $logfolder		$DateEnded = Get-date	Add-LogContent "Green" "-----------------------------------"	Add-LogContent "Green" "| Automated Script - SPSWakeUp |"	Add-LogContent "Green" "| Started on : $DateStarted |"	Add-LogContent "Green" "| Completed on : $DateEnded |"	Add-LogContent "Green" "-----------------------------------"	$global:MailContent += "<br>"	$global:MailContent += "Automated Script - WarmUp Urls - Completed on: $DateEnded"	Trap {Continue}		Save-LogFile $logFile		# Send Email with log file in attachment - For settings see XML input file	Send-SPSLog -XmlFile $xmlinput -MailAttachment $logFile -MailBody $global:MailContent		Exit}#endregion